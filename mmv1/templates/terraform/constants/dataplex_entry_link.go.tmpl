// CreateEntryLink supports exactly 1 required aspect. 
const maxEntryLinkAspectNumber = 1

// NumberOfEntryLinkAspectsValidation checks if the number of aspects on an entry exceeds certain threshold.
func NumberOfEntryLinkAspectsValidation(i interface{}, k string) (warnings []string, errors []error) {
	s, isSlice := i.([]interface{})
	m, isMap := i.(map[string]interface{})

	if !isSlice && !isMap {
		errors = append(errors, fmt.Errorf("expected type of field %q to be array, but got %T", k, i))
		return warnings, errors
	}

	if len(s)+len(m) > maxEntryLinkAspectNumber {
		errors = append(errors, fmt.Errorf(
			"field %q has an invalid content: %q. The maximal number of aspects is 99.",
			k, i,
		))
	}

	return warnings, errors
}

// ProjectNumberValidation checks if the input string conforms to the pattern:
// "projects/<project-number>/<anything>"
func EntryLinkAspectProjectNumberValidation(i interface{}, k string) (warnings []string, errors []error) {
	v, ok := i.(string)
	if !ok {
		errors = append(errors, fmt.Errorf("expected type of field %q to be string, but got %T", k, i))
		return warnings, errors
	}

	var numberDotAnythingRegex = regexp.MustCompile(`^[1-9]\d*\..+$`)

	if !numberDotAnythingRegex.MatchString(v) {
		errors = append(errors, fmt.Errorf(
			"field %q has an invalid format: %q. Expected format: '<project number>.anything'. Please note that project IDs are not supported.",
			k, v,
		))
	}

	return warnings, errors
}

// AddEntryLinkAspectsToSet adds aspect keys from the aspects interface to the aspectKeySet.
// It returns an error if type assertions fail or expected keys are missing.
func AddEntryLinkAspectsToSet(aspectTypeKeySet map[string]struct{}, aspects interface{}) error {
	if aspects == nil {
		return nil
	}
	aspectsSlice, ok := aspects.([]interface{})
	if !ok {
		return fmt.Errorf("AddEntryLinkAspectsToSet: input 'aspects' is not a []interface{}, got %T", aspects)
	}

	for i, aspectItemRaw := range aspectsSlice {
		aspectMap, ok := aspectItemRaw.(map[string]interface{})
		if !ok {
			return fmt.Errorf("AddEntryLinkAspectsToSet: item at index %d is not a map[string]interface{}, got %T", i, aspectItemRaw)
		}

		keyRaw, keyExists := aspectMap["aspect_type"]
		if !keyExists {
			return fmt.Errorf("AddEntryLinkAspectsToSet: 'aspect_type' not found in aspect item at index %d", i)
		}

		keyString, ok := keyRaw.(string)
		if !ok {
			return fmt.Errorf("AddEntryLinkAspectsToSet: 'aspect_type' in item at index %d is not a string, got %T", i, keyRaw)
		}
		aspectTypeKeySet[keyString] = struct{}{}
	}
	return nil
}

// InverseTransformAspects converts the "aspects" map back to a slice of maps,
// re-inserting the "aspectType". Modifies obj in-place.
// It returns an error if type assertions fail.
func InverseTransformEntryLinkAspects(res map[string]interface{}) error {
	aspectsRaw, ok := res["aspects"]
	if !ok || aspectsRaw == nil {
		return nil
	}

	originalMap, ok := aspectsRaw.(map[string]interface{})
	if !ok {
		return fmt.Errorf("InverseTransformEntryLinkAspects: 'aspects' field is not a map[string]interface{}, got %T", aspectsRaw)
	}

	newSlice := make([]interface{}, 0, len(originalMap))

	for key, value := range originalMap {
		innerMap, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("InverseTransformEntryLinkAspects: value for key '%s' is not a map[string]interface{}, got %T", key, value)
		}
		box := make(map[string]interface{}, 2)
		box["aspectType"] = key
		box["aspect"] = innerMap
		newSlice = append(newSlice, box)
	}
	res["aspects"] = newSlice
	return nil
}

// TransformAspects concisely transforms the "aspects" slice within obj into a map.
// Modifies obj in-place.
// It returns an error if type assertions fail or expected keys are missing.
func TransformEntryLinkAspects(obj map[string]interface{}) error {
	aspectsRaw, ok := obj["aspects"]
	if !ok || aspectsRaw == nil {
		return nil
	}

	originalSlice, ok := aspectsRaw.([]interface{})
	if !ok {
		return fmt.Errorf("TransformAspects: 'aspects' field is not a []interface{}, got %T", aspectsRaw)
	}

	newMap := make(map[string]interface{}, len(originalSlice))
	for i, item := range originalSlice {
		aspectMap, ok := item.(map[string]interface{})
		if !ok {
			return fmt.Errorf("TransformEntryLinkAspects: item in 'aspects' slice at index %d is not a map[string]interface{}, got %T", i, item)
		}

		keyRaw, keyExists := aspectMap["aspectType"]
		if !keyExists {
			return fmt.Errorf("TransformEntryLinkAspects: 'aspectType' not found in aspect item at index %d", i)
		}
		key, ok := keyRaw.(string)
		if !ok {
			return fmt.Errorf("TransformEntryLinkAspects: 'aspectType' in item at index %d is not a string, got %T", i, keyRaw)
		}

		valueRaw, valueExists := aspectMap["aspect"]
		if !valueExists {
			newMap[key] = map[string]interface{}{"data": map[string]interface{}{}}
			continue
		}

		value, ok := valueRaw.(map[string]interface{})
		if ok {
			newMap[key] = value
		} else {
			newMap[key] = map[string]interface{}{"data": map[string]interface{}{}}
		}
	}
	obj["aspects"] = newMap
	return nil
}
