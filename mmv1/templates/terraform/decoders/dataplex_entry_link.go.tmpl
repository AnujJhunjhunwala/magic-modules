// This decoder validates the number of aspects, filters the API response to include only 
// aspects defined in the configuration (preserving all aspects during import/empty config), 
// and transforms the aspect map into a slice.
aspects := res["aspects"]
if aspects != nil {
	_, errs := NumberOfEntryLinkAspectsValidation(aspects, "aspects")

	if len(errs) > 0 {
		var msgs []string
		for _, e := range errs {
			msgs = append(msgs, e.Error())
		}
		return nil, fmt.Errorf("aspects validation failed: %s", strings.Join(msgs, "; "))
	}
}

aspectTypeKeysOfInterest := make(map[string]struct{})
var err error

if d.HasChange("aspects") {
	currentAspects, futureAspects := d.GetChange("aspects")
	err = AddEntryLinkAspectsToSet(aspectTypeKeysOfInterest, currentAspects)
	if err != nil {
		return nil, err
	}
	err = AddEntryLinkAspectsToSet(aspectTypeKeysOfInterest, futureAspects)
	if err != nil {
		return nil, err
	}
} else {
	err = AddEntryLinkAspectsToSet(aspectTypeKeysOfInterest, d.Get("aspects"))
	if err != nil {
		return nil, err
	}
}

if len(aspectTypeKeysOfInterest) > 0 {
	err = FilterAspects(aspectTypeKeysOfInterest, res)
	if err != nil {
		return nil, err
	}
}

err = InverseTransformEntryLinkAspects(res)
if err != nil {
	return nil, err
}

return res, nil